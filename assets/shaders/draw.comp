#version 450
#extension GL_ARB_gpu_shader_int64 : enable
#extension GL_ARB_bindless_texture : enable

#include assets/shaders/camera.glsl
#include assets/shaders/sdf.glsl

layout(local_size_x = 32,  local_size_y = 32) in;

layout(rgba8, binding = 0) writeonly uniform image2D frame;

const vec3 SUN_POS = vec3(0., 100., 400.);

layout (binding = 1) uniform u_Camera {
    vec4 C_position;
    mat4 C_view;
    uint64_t handle;
};

float voxelDDA(in vec3 rayOrigin, in vec3 rayDir, out ivec3 pos, out vec3 normal) {
    ivec3 mapPos = ivec3(floor(rayOrigin.xyz + 0.));
    vec3 deltaDist = abs(vec3(length(rayDir.xyz)) / rayDir.xyz);
    ivec3 rayStep = ivec3(sign(rayDir.xyz));

    vec3 sideDist = (sign(rayDir.xyz) * (vec3(mapPos) - rayOrigin.xyz) + (sign(rayDir.xyz) * 0.5) + 0.5) * deltaDist;
    bvec3 mask = bvec3(false);

    layout(rgba8) image3D vox = layout(rgba8) image3D(handle);

    for (int i = 0; i < 384; i++) {
    
        vec4 voxel = imageLoad(vox, mapPos);

		if (length(voxel) > 0.)
        {
            normal = vec3(mask);
            pos = mapPos;
            return length(vec3(mask) * (sideDist - deltaDist)) / length(rayDir);
        }
            
        mask = lessThanEqual(sideDist.xyz, min(sideDist.yzx, sideDist.zxy));			
		sideDist += vec3(mask) * deltaDist;
		mapPos += ivec3(vec3(mask)) * rayStep;
	}

    return -1;
}

void main() {
    ivec2 pixelCoords = ivec2(gl_GlobalInvocationID.xy);
    ivec2 size = imageSize(frame);

    if (pixelCoords.x >= size.x || pixelCoords.y >= size.y) 
        return;

    vec2 rayUV = vec2(pixelCoords) / vec2(size) * 2.0 - 1.0;
    rayUV.y *= float(size.y) / float(size.x);

    vec4 rayOrigin = C_position;
    vec4 rayDir = C_view * normalize(vec4(rayUV, 1.0, 1.0));

    ivec3 vpos;
    vec3 normal;
    float d = voxelDDA(rayOrigin.xyz, rayDir.xyz, vpos, normal);
    if (d > 0.) {
        vec3 intersectionPoint = rayOrigin.xyz + rayDir.xyz * d + 0.01;
        vec3 shadowDirection = normalize(SUN_POS - intersectionPoint);

        float coeff = 1.0;

        ivec3 svPos;
        vec3 svNorm;
        
        if (voxelDDA(intersectionPoint, shadowDirection, svPos, svNorm) > 0.)
            coeff *= 0.4;

        imageStore(frame, pixelCoords, vec4(Reinhardt(normal * dot(normal, vec3(0.75, 0.5, 0.5)) * coeff), 1.0));
        return;
    }

    /// sky coloring according to ray direction
    vec4 skyColor = SkyDome(rayOrigin.xyz, rayDir.xyz);
    imageStore(frame, pixelCoords, vec4(Reinhardt(skyColor.xyz), 1.0));
}