#version 450
#extension GL_ARB_gpu_shader_int64 : enable

#include assets/shaders/camera.glsl
#include assets/shaders/dda.glsl
#include assets/shaders/map.glsl

layout(local_size_x = 32,  local_size_y = 32) in;

layout(rgba8, binding = 0) writeonly uniform image2D frame;

layout (binding = 1) uniform u_Camera {
    vec4 C_position;
    mat4 C_view;
    vec4 C_sun_pos;
};

float vertexAo(vec2 side, float corner) {
	return (side.x + side.y + max(corner, side.x * side.y)) / 4.0;
}

vec4 voxelAo(vec3 pos, vec3 d1, vec3 d2) {
	vec4 side = vec4(length(map_getVoxel(ivec3(pos + d1))) > 0., length(map_getVoxel(ivec3(pos + d2))) > 0., length(map_getVoxel(ivec3(pos - d1))) > 0., length(map_getVoxel((ivec3(pos - d2)))) > 0.);
	vec4 corner = vec4(length(map_getVoxel(ivec3(pos + d1 + d2))) > 0., length(map_getVoxel(ivec3(pos - d1 + d2))) > 0., length(map_getVoxel(ivec3(pos - d1 - d2))) > 0., length(map_getVoxel(ivec3(pos + d1 - d2))) > 0.);
	vec4 ao;
	ao.x = vertexAo(side.xy, corner.x);
	ao.y = vertexAo(side.yz, corner.y);
	ao.z = vertexAo(side.zw, corner.z);
	ao.w = vertexAo(side.wx, corner.w);
	return 1.0 - ao;
}

float shadowTrace(in vec3 rayOrigin, in vec3 rayDir) {
    ivec3 mapPos;
    vec3 deltaDist;
    ivec3 rayStep;
    vec3 sideDist;
    bvec3 mask;

    dda_init(rayOrigin, rayDir, mapPos, deltaDist, rayStep, sideDist, mask);

    for (int i = 0; i < 128; i++) {
    
        vec4 voxel = map_getVoxel(mapPos);

		if (length(voxel) > 0.)
            return dda_distance(rayDir, deltaDist, sideDist, mask);
        

        dda_step(mapPos, deltaDist, rayStep, sideDist, mask);
	}

    return -1;
}


void main() {
    ivec2 pixelCoords = ivec2(gl_GlobalInvocationID.xy);
    ivec2 size = imageSize(frame);

    if (pixelCoords.x >= size.x || pixelCoords.y >= size.y) 
        return;

    vec2 rayUV = vec2(pixelCoords) / vec2(size) * 2.0 - 1.0;
    rayUV.y *= float(size.y) / float(size.x);

    vec4 rayOrigin = C_position;
    vec4 rayDir = normalize(C_view * vec4(rayUV, 1.0, 1.0));

    vec2 intersection = intersectAABB(rayOrigin.xyz, rayDir.xyz , vec3(0.), vec3(0256.0));

    if (intersection.x < intersection.y) 
    {
        vec3 volumeRayOrigin = rayOrigin.xyz + rayDir.xyz * max(intersection.x, 0) - 0.001;

        ivec3 mapPos;
        vec3 deltaDist;
        ivec3 rayStep;
        vec3 sideDist;
        bvec3 mask;

        dda_init(volumeRayOrigin, rayDir.xyz, mapPos, deltaDist, rayStep, sideDist, mask);

        for (int i = 0; i < 384; i++) {
    
            vec4 voxel = map_getVoxel(mapPos);

		    if (length(voxel) > 0.)
            {
                vec3 normal = ceil(vec3(mask));

                vec3 intersectionPoint = volumeRayOrigin + rayDir.xyz * dda_distance(rayDir.xyz, deltaDist, sideDist, mask) + 0.0001;
                vec3 shadowDirection = normalize(C_sun_pos.xyz - intersectionPoint);

                float coeff = 1.0;

                if (shadowTrace(intersectionPoint, shadowDirection) > 0.)
                    coeff *= 0.4;

	            vec2 uv;
	            vec4 ambient;
            
	            ambient = voxelAo(vec3(mapPos) - rayStep * vec3(mask), vec3(mask.zxy), vec3(mask.yzx));            
	            uv = mod(vec2(dot(vec3(mask) * intersectionPoint.yzx, vec3(1.0)), dot(vec3(mask) * intersectionPoint.zxy, vec3(1.0))), vec2(1.0));
            
	            float interpAo = mix(mix(ambient.z, ambient.w, uv.x), mix(ambient.y, ambient.x, uv.x), uv.y);

                imageStore(frame, pixelCoords, vec4(Reinhardt(normal * interpAo * coeff), 1.0));
                return;
            }

            dda_step(mapPos, deltaDist, rayStep, sideDist, mask);
	    }
    }

    /// sky coloring according to ray direction
    vec4 skyColor = SkyDome(rayOrigin.xyz, rayDir.xyz);
    imageStore(frame, pixelCoords, vec4(Reinhardt(skyColor.xyz), 1.0));
}