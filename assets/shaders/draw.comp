#version 450
#extension GL_ARB_gpu_shader_int64 : enable
#extension GL_ARB_bindless_texture : enable

#include assets/shaders/camera.glsl
#include assets/shaders/sdf.glsl
#include assets/shaders/dda.glsl

layout(local_size_x = 32,  local_size_y = 32) in;

layout(rgba8, binding = 0) writeonly uniform image2D frame;

const vec3 SUN_POS = vec3(100., 100., 400.);

layout (binding = 1) uniform u_Camera {
    vec4 C_position;
    mat4 C_view;
    uint64_t handle;
};

vec2 intersectAABB(vec3 rayOrigin, vec3 rayDir, vec3 boxMin, vec3 boxMax) {
    vec3 tMin = (boxMin - rayOrigin) / rayDir;
    vec3 tMax = (boxMax - rayOrigin) / rayDir;
    vec3 t1 = min(tMin, tMax);
    vec3 t2 = max(tMin, tMax);
    float tNear = max(max(t1.x, t1.y), t1.z);
    float tFar = min(min(t2.x, t2.y), t2.z);
    return vec2(tNear, tFar);
};

float voxelDDA(in vec3 rayOrigin, in vec3 rayDir, out ivec3 pos, out vec3 normal) {
    ivec3 mapPos;
    vec3 deltaDist;
    ivec3 rayStep;
    vec3 sideDist;
    bvec3 mask;

    dda_init(rayOrigin, rayDir, mapPos, deltaDist, rayStep, sideDist, mask);

    layout(rgba8) image3D vox = layout(rgba8) image3D(handle);

    for (int i = 0; i < 384; i++) {
    
        vec4 voxel = imageLoad(vox, mapPos);

		if (length(voxel) > 0.)
        {
            normal = vec3(mask);
            pos = mapPos;
            return dda_distance(rayDir, deltaDist, sideDist, mask);
        }

        dda_step(mapPos, deltaDist, rayStep, sideDist, mask);
	}

    return -1;
}

void main() {
    ivec2 pixelCoords = ivec2(gl_GlobalInvocationID.xy);
    ivec2 size = imageSize(frame);

    if (pixelCoords.x >= size.x || pixelCoords.y >= size.y) 
        return;

    vec2 rayUV = vec2(pixelCoords) / vec2(size) * 2.0 - 1.0;
    rayUV.y *= float(size.y) / float(size.x);

    vec4 rayOrigin = C_position;
    vec4 rayDir = normalize(C_view * vec4(rayUV, 1.0, 1.0));

    vec2 intersection = intersectAABB(rayOrigin.xyz, rayDir.xyz , vec3(32.), vec3(32 + 256.0));

    if (intersection.x < intersection.y) 
    {
        vec3 volumeRayOrigin = rayOrigin.xyz + rayDir.xyz * max(intersection.x, 0) - vec3(32.) - 0.001;

        ivec3 vpos;
        vec3 normal;

        float d = voxelDDA(volumeRayOrigin, rayDir.xyz, vpos, normal);
        if (d > 0.) {
            float coeff = 1.0;

            vec3 intersectionPoint = volumeRayOrigin + rayDir.xyz * d + 0.001;
            vec3 shadowDirection = normalize(SUN_POS - intersectionPoint);

            ivec3 svPos;
            vec3 svNorm;

            normal = ceil(normal);

            if (voxelDDA(intersectionPoint, shadowDirection, svPos, svNorm) > 0.)
                coeff *= 0.4;   

            imageStore(frame, pixelCoords, vec4(Reinhardt(normal * dot(normal, vec3(0.75, 0.5, 0.5)) * coeff), 1.0));
            return;
        }
    }

    /// sky coloring according to ray direction
    vec4 skyColor = SkyDome(rayOrigin.xyz, rayDir.xyz);
    imageStore(frame, pixelCoords, vec4(Reinhardt(skyColor.xyz), 1.0));
}