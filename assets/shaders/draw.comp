#version 450

#include assets/shaders/camera.glsl
#include assets/shaders/sdf.glsl

layout(local_size_x = 32,  local_size_y = 32) in;

layout(rgba8, binding = 0) writeonly uniform image2D frame;

const vec3 SUN_POS = vec3(0., 100., 0.);

layout (binding = 1) uniform u_Camera {
    vec4 C_position;
    mat4 C_view;
};

bool getVoxel(ivec3 pos) {
    // pos = ivec3(mod(vec3(pos), vec3(16.)));
    float planeDist = -sdPlane(vec3(pos), vec3(0., 1.0, 0.), 1.0);
    float boxDist = -sdBoxFrame(vec3(pos), vec3(0.0), vec3(16.0), 0.5);
    return max(planeDist, boxDist) < 0.;
}

bool voxelDDA(in vec3 rayOrigin, in vec3 rayDir, out ivec3 pos, out vec3 normal) {
    ivec3 mapPos = ivec3(floor(rayOrigin.xyz + 0.));
    vec3 deltaDist = abs(vec3(length(rayDir.xyz)) / rayDir.xyz);
    ivec3 rayStep = ivec3(sign(rayDir.xyz));

    vec3 sideDist = (sign(rayDir.xyz) * (vec3(mapPos) - rayOrigin.xyz) + (sign(rayDir.xyz) * 0.5) + 0.5) * deltaDist;
    bvec3 mask = bvec3(false);

    for (int i = 0; i < 256; i++) {

		if (!getVoxel(mapPos))
        {
            normal = vec3(mask);
            pos = mapPos;
            return true;
        }
            
        mask = lessThanEqual(sideDist.xyz, min(sideDist.yzx, sideDist.zxy));			
		sideDist += vec3(mask) * deltaDist;
		mapPos += ivec3(vec3(mask)) * rayStep;
	}

    return false;
}

void main() {
    ivec2 pixelCoords = ivec2(gl_GlobalInvocationID.xy);
    ivec2 size = imageSize(frame);

    if (pixelCoords.x >= size.x || pixelCoords.y >= size.y) 
        return;

    vec2 rayUV = vec2(pixelCoords) / vec2(size) * 2.0 - 1.0;
    rayUV.y *= float(size.y) / float(size.x);

    vec4 rayOrigin = C_position;
    vec4 rayDir = C_view * normalize(vec4(rayUV, 1.0, 1.0));

    ivec3 vpos;
    vec3 normal;
    if (voxelDDA(rayOrigin.xyz, rayDir.xyz, vpos, normal)) {
        vec3 shadowPos = vec3(vpos);
        vec3 shadowDir = SUN_POS - vec3(vpos);

        ivec3 spos;
        vec3 snorm;
        float coeff = 1.0;

        if (voxelDDA(shadowPos + normal, shadowDir, spos, snorm))
            coeff *= 0.2;

        imageStore(frame, pixelCoords, vec4(normal * coeff, 1.0));
        return;
    }

    /// sky coloring according to ray direction
    vec4 skyColor = SkyDome(rayOrigin.xyz, rayDir.xyz);
    imageStore(frame, pixelCoords, skyColor);
}