#version 450

#include assets/shaders/camera.glsl

layout(local_size_x = 32,  local_size_y = 32) in;

layout(rgba8, binding = 0) writeonly uniform image2D frame;

layout (binding = 1) uniform u_Camera {
    vec4 C_position;
    mat4 C_view;
};

struct AABB {
    vec3 minBound;
    vec3 maxBound;
    vec3 pos;
};


vec2 intersectAABB(vec3 rayOrigin, vec3 rayDir, AABB box) {
    vec3 tMin = (box.minBound - rayOrigin) / rayDir;
    vec3 tMax = (box.maxBound - rayOrigin) / rayDir;
    vec3 t1 = min(tMin, tMax);
    vec3 t2 = max(tMin, tMax);
    float tNear = max(max(t1.x, t1.y), t1.z);
    float tFar = min(min(t2.x, t2.y), t2.z);
    return vec2(tNear, tFar);
};

void main() {
    ivec2 pixelCoords = ivec2(gl_GlobalInvocationID.xy);
    ivec2 size = imageSize(frame);

    if (pixelCoords.x >= size.x || pixelCoords.y >= size.y) 
        return;

    vec2 rayUV = vec2(pixelCoords) / vec2(size) * 2.0 - 1.0;
    rayUV.y *= float(size.y) / float(size.x);

    vec4 rayOrigin = C_position;
    vec4 rayDir = C_view * normalize(vec4(rayUV, 1.0, 1.0));

    AABB bbox = AABB(vec3(-1.0), vec3(2.0), vec3(0.0)); 
    vec2 t = intersectAABB(rayOrigin.xyz, rayDir.xyz, bbox);

    if (t.x <= t.y) {
        imageStore(frame, pixelCoords, vec4(1.0, 0.0, 0.0, 1.0));
        return;
    }

    vec4 color = SkyDome(rayOrigin.xyz, rayDir.xyz);
    imageStore(frame, pixelCoords, color);
}